<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorium Wahadła</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #22d3ee; margin-top: -6px; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px;
        }
        aside::-webkit-scrollbar { width: 6px; }
        aside::-webkit-scrollbar-track { background: #1f2937; }
        aside::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        
        .tab-btn.active { border-bottom: 2px solid #22d3ee; color: #22d3ee; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans h-screen flex flex-col overflow-hidden">

    <!-- Nagłówek -->
    <header class="flex items-center justify-between px-6 py-4 bg-gray-800 border-b border-gray-700 shadow-md shrink-0 z-20">
        <div class="flex items-center space-x-3">
            <div class="bg-cyan-600 p-2 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="M2 12h5l3 5 5-10 4 6h3"/></svg>
            </div>
            <h1 id="app-title" class="text-xl font-bold tracking-wide">Laboratorium Wahadła</h1>
        </div>

        <div class="flex space-x-6 text-sm font-medium">
            <button class="tab-btn active px-3 py-2 transition-colors hover:text-cyan-300" onclick="switchTab(1)" id="tab-1-btn">Badanie (Pojedyncze)</button>
            <button class="tab-btn px-3 py-2 transition-colors hover:text-cyan-300" onclick="switchTab(2)" id="tab-2-btn">Liniowe vs Dokładne</button>
            <button class="tab-btn px-3 py-2 transition-colors hover:text-cyan-300" onclick="switchTab(3)" id="tab-3-btn">Porównanie (Dwa)</button>
        </div>
        
        <button id="btn-lang" class="flex items-center px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm font-bold transition-colors border border-gray-600" onclick="toggleLang()">
            <span id="lang-label">EN</span>
        </button>
    </header>

    <!-- Kontener Główny -->
    <div class="flex flex-1 overflow-hidden relative">

        <!-- PANEL STEROWANIA -->
        <aside class="w-80 bg-gray-800 p-6 flex flex-col gap-5 overflow-y-auto border-r border-gray-700 shadow-xl z-10 shrink-0">
            <!-- Sterowanie główne -->
            <div class="space-y-4 border-b border-gray-700 pb-4">
                <div class="flex items-center space-x-2">
                    <button id="btn-play" class="flex-1 flex items-center justify-center py-2 rounded font-semibold transition-all shadow-lg bg-green-500 text-white hover:bg-green-600" onclick="togglePlay()">
                        <span id="txt-play">Start</span>
                    </button>
                    <button class="p-2 bg-gray-700 hover:bg-gray-600 rounded text-gray-300 border border-gray-600" onclick="resetSim()" title="Reset">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                    </button>
                </div>
                <!-- Suwak szybkości -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs text-gray-400 uppercase font-bold" id="lbl-speed">Szybkość symulacji</label>
                        <span class="text-xs font-mono text-cyan-400" id="val-speed">1.0x</span>
                    </div>
                    <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" class="w-full accent-cyan-500" id="inp-speed" oninput="updateSpeed(this.value)">
                </div>
            </div>

            <div id="controls-container" class="space-y-6"></div>
            
            <!-- Legenda -->
            <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-2 mt-auto text-xs font-mono">
                <div class="font-bold text-gray-400 mb-1 border-b border-gray-700 pb-1">Wektory Sił:</div>
                <div id="legend-content"></div>
                <hr class="border-gray-700 my-2">
                <div id="stats-output"></div>
            </div>
        </aside>

        <!-- OBSZAR ROBOCZY -->
        <main class="flex-1 relative bg-gray-900 flex flex-col">
            
            <!-- Widok: Tab 1 -->
            <div id="view-tab-1" class="w-full h-full flex flex-col">
                <!-- Główny Canvas Symulacji -->
                <div class="flex-1 relative border-b border-gray-700 min-h-0">
                    <canvas id="canvas-1" class="w-full h-full block cursor-crosshair"></canvas>
                    <div class="absolute top-4 right-4 text-xs text-gray-500 font-mono">Badanie Wahadła</div>
                </div>
                <!-- Wykresy -->
                <div class="h-64 bg-gray-900 border-t border-gray-800 flex flex-col shrink-0">
                    <div class="h-1/2 w-full border-b border-gray-800 p-1 relative">
                        <canvas id="chart-1-angle" class="w-full h-full block"></canvas>
                    </div>
                    <div class="h-1/2 w-full p-1 relative">
                        <canvas id="chart-1-vel" class="w-full h-full block"></canvas>
                    </div>
                </div>
            </div>

            <!-- Widok: Tab 2 -->
            <div id="view-tab-2" class="w-full h-full hidden flex-col">
                <div class="flex-1 relative border-b border-gray-700 min-h-0">
                    <canvas id="canvas-2" class="w-full h-full block cursor-crosshair"></canvas>
                    <div class="absolute top-4 right-4 text-xs text-gray-500 font-mono">Matematyczne (Niebieskie) vs Fizyczne (Pomarańczowe)</div>
                </div>
                <div class="h-64 bg-gray-900 border-t border-gray-800 flex flex-col shrink-0">
                    <div class="h-1/2 w-full border-b border-gray-800 p-1">
                        <canvas id="chart-2-angle" class="w-full h-full block"></canvas>
                    </div>
                    <div class="h-1/2 w-full p-1">
                        <canvas id="chart-2-vel" class="w-full h-full block"></canvas>
                    </div>
                </div>
            </div>

            <!-- Widok: Tab 3 -->
            <div id="view-tab-3" class="w-full h-full hidden flex-col">
                <div class="flex-1 relative border-b border-gray-700 min-h-0">
                    <canvas id="canvas-3" class="w-full h-full block cursor-crosshair"></canvas>
                    <div class="absolute top-4 right-4 text-xs text-gray-500 font-mono">Wahadło A (Niebieskie) vs B (Różowe)</div>
                </div>
                <div class="h-64 bg-gray-900 border-t border-gray-800 flex flex-col shrink-0">
                    <div class="h-1/2 w-full border-b border-gray-800 p-1">
                        <canvas id="chart-3-angle" class="w-full h-full block"></canvas>
                    </div>
                    <div class="h-1/2 w-full p-1">
                        <canvas id="chart-3-vel" class="w-full h-full block"></canvas>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <script>
        // --- SILNIK FIZYCZNY ---
        class Pendulum {
            constructor(length, mass, angleDeg, damping, gravity, type = 'exact') {
                this.L = length; 
                this.m = mass;   
                this.theta = angleDeg * Math.PI / 180;
                this.omega = 0;
                this.b = damping; 
                this.g = gravity;
                this.type = type; 
                this.initParams = { L: length, m: mass, theta: this.theta, b: damping, g: gravity };
            }

            update(dt) {
                if (isNaN(this.theta) || isNaN(this.omega)) { this.reset(); return; }
                const I = this.m * this.L * this.L;
                if (I < 0.00001) return; 

                let restoringTerm = 0;
                if (this.type === 'linear') {
                    restoringTerm = this.theta;
                } else {
                    restoringTerm = Math.sin(this.theta);
                }

                const torqueG = -this.m * this.g * this.L * restoringTerm;
                const torqueB = -this.b * this.omega;
                const alpha = (torqueG + torqueB) / I;
                
                this.omega += alpha * dt;
                this.theta += this.omega * dt;
            }

            reset() { this.theta = this.initParams.theta; this.omega = 0; }
        }

        // --- RYSOWANIE WYKRESÓW ---
        class MultiChartRenderer {
            constructor(canvasId, title) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.data = { A: [], B: [] }; 
                this.maxPoints = 600; 
                this.title = title;
                this.fixedMaxY = null;
            }

            setFixedScale(limitValue) {
                this.fixedMaxY = Math.abs(limitValue) > 0.01 ? Math.abs(limitValue) * 1.2 : 1.0;
            }

            push(valA, valB) {
                this.data.A.push(valA);
                if (valB !== null) this.data.B.push(valB);
                if (this.data.A.length > this.maxPoints) {
                    this.data.A.shift();
                    if(this.data.B.length > 0) this.data.B.shift();
                }
            }

            clear() { this.data.A = []; this.data.B = []; }

            draw(colorA, colorB, labelA, labelB) {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const ctx = this.ctx;
                
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; 
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                
                let maxVal = this.fixedMaxY !== null ? this.fixedMaxY : 1.0;
                const scaleY = (h / 2) / maxVal;
                const stepX = w / this.maxPoints;

                ctx.setLineDash([2, 4]); ctx.strokeStyle = '#1f2937';
                let yLine = h/2 - (maxVal/2)*scaleY;
                ctx.beginPath(); ctx.moveTo(0, yLine); ctx.lineTo(w, yLine); ctx.stroke();
                yLine = h/2 + (maxVal/2)*scaleY;
                ctx.beginPath(); ctx.moveTo(0, yLine); ctx.lineTo(w, yLine); ctx.stroke();
                ctx.setLineDash([]);

                this.drawLine(ctx, this.data.A, stepX, h, scaleY, colorA);
                if(this.data.B.length > 0) this.drawLine(ctx, this.data.B, stepX, h, scaleY, colorB);

                ctx.font = '10px monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'right';
                ctx.fillText(maxVal.toFixed(2), w - 4, 12);
                ctx.fillText((-maxVal).toFixed(2), w - 4, h - 4);
                ctx.fillText("0", w - 4, h/2 - 2);

                ctx.textAlign = 'left';
                ctx.fillStyle = '#9ca3af'; ctx.fillText(this.title, 5, 12);
                ctx.fillStyle = colorA; ctx.fillText(labelA, 5, h - 5);
                if(labelB) { 
                    ctx.textAlign = 'center';
                    ctx.fillStyle = colorB; ctx.fillText(labelB, w/2, h - 5); 
                }
            }

            drawLine(ctx, data, stepX, h, scaleY, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((val, i) => {
                    const x = i * stepX;
                    const y = h/2 - val * scaleY;
                    if (i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
        }

        // --- GLOBALNE ---
        let activeTab = 1;
        let lang = 'pl';
        let isPlaying = false;
        let timeSpeed = 1.0;
        let lastTime = 0;
        let animationId;

        const sims = {
            1: { 
                p1: new Pendulum(1.5, 2, 45, 0.0, 9.81, 'exact'), 
                chartAngle: new MultiChartRenderer('chart-1-angle', 'Kąt / Angle (rad)'),
                chartVel: new MultiChartRenderer('chart-1-vel', 'Prędkość / Velocity (rad/s)')
            },
            2: { 
                pLinear: new Pendulum(1.5, 2, 45, 0, 9.81, 'linear'), 
                pExact: new Pendulum(1.5, 2, 45, 0, 9.81, 'exact'),
                chartAngle: new MultiChartRenderer('chart-2-angle', 'Kąt (rad)'),
                chartVel: new MultiChartRenderer('chart-2-vel', 'Prędkość (rad/s)')
            },
            3: { 
                pA: new Pendulum(1.5, 2, 30, 0, 9.81, 'exact'), 
                pB: new Pendulum(1.0, 2, 30, 0, 9.81, 'exact'),
                chartAngle: new MultiChartRenderer('chart-3-angle', 'Kąt (rad)'),
                chartVel: new MultiChartRenderer('chart-3-vel', 'Prędkość (rad/s)')
            }
        };

        const uiConfig = {
            1: [
                { id: 'len', labelPL: 'Długość (L)', labelEN: 'Length (L)', min: 0.1, max: 3, step: 0.1, val: 1.5, unit: 'm', target: 'p1', prop: 'L' },
                { id: 'mass', labelPL: 'Masa (m)', labelEN: 'Mass (m)', min: 0.1, max: 10, step: 0.1, val: 2.0, unit: 'kg', target: 'p1', prop: 'm' },
                { id: 'angle', labelPL: 'Kąt pocz. (θ)', labelEN: 'Init. Angle (θ)', min: -90, max: 90, step: 1, val: 45, unit: '°', target: 'p1', prop: 'theta', isAngle: true },
                { id: 'damp', labelPL: 'Tłumienie (b)', labelEN: 'Damping (b)', min: 0, max: 2, step: 0.05, val: 0.0, unit: '', target: 'p1', prop: 'b' },
                { id: 'grav', labelPL: 'Grawitacja (g)', labelEN: 'Gravity (g)', min: 1, max: 20, step: 0.1, val: 9.81, unit: 'm/s²', target: 'p1', prop: 'g' }
            ],
            2: [
                { headerPL: 'Parametry Wspólne', headerEN: 'Common Parameters' },
                { id: 'len2', labelPL: 'Długość (L)', labelEN: 'Length (L)', min: 0.5, max: 3, step: 0.1, val: 1.5, unit: 'm', target: ['pLinear', 'pExact'], prop: 'L' },
                { id: 'angle2', labelPL: 'Kąt pocz. (θ)', labelEN: 'Init. Angle (θ)', min: 1, max: 90, step: 1, val: 45, unit: '°', target: ['pLinear', 'pExact'], prop: 'theta', isAngle: true },
                { id: 'mass2', labelPL: 'Masa (m)', labelEN: 'Mass (m)', min: 0.5, max: 5, step: 0.1, val: 2, unit: 'kg', target: ['pLinear', 'pExact'], prop: 'm' }
            ],
            3: [
                { headerPL: 'Wahadło A (Niebieskie)', headerEN: 'Pendulum A (Blue)' },
                { id: 'len3a', labelPL: 'Długość', labelEN: 'Length', min: 0.1, max: 3, step: 0.1, val: 1.5, unit: 'm', target: 'pA', prop: 'L' },
                { id: 'grav3a', labelPL: 'Grawitacja', labelEN: 'Gravity', min: 1, max: 20, step: 0.1, val: 9.81, unit: 'm/s²', target: 'pA', prop: 'g' },
                { headerPL: 'Wahadło B (Różowe)', headerEN: 'Pendulum B (Pink)' },
                { id: 'len3b', labelPL: 'Długość', labelEN: 'Length', min: 0.1, max: 3, step: 0.1, val: 1.0, unit: 'm', target: 'pB', prop: 'L' },
                { id: 'grav3b', labelPL: 'Grawitacja', labelEN: 'Gravity', min: 1, max: 20, step: 0.1, val: 9.81, unit: 'm/s²', target: 'pB', prop: 'g' },
                { headerPL: 'Wspólne', headerEN: 'Common' },
                { id: 'angle3', labelPL: 'Kąt pocz.', labelEN: 'Init. Angle', min: 10, max: 90, step: 1, val: 30, unit: '°', target: ['pA', 'pB'], prop: 'theta', isAngle: true }
            ]
        };

        const translations = {
            pl: {
                title: 'Laboratorium Wahadła',
                tab1: 'Badanie (Pojedyncze)', tab2: 'Liniowe vs Dokładne', tab3: 'Porównanie (Dwa)',
                start: 'Start', stop: 'Stop',
                legend1: `
                    <div class="flex items-center gap-2 text-green-400"><div class="w-3 h-3 bg-green-500 rounded-full"></div> Prędkość (v)</div>
                    <div class="flex items-center gap-2 text-red-400"><div class="w-3 h-3 bg-red-500 rounded-full"></div> Siła Styczna ($F_t$)</div>
                    <div class="flex items-center gap-2 text-yellow-400"><div class="w-3 h-3 bg-yellow-500 rounded-full"></div> Naciąg (N)</div>
                    <div class="flex items-center gap-2 text-gray-400"><div class="w-3 h-3 bg-gray-500 rounded-full"></div> Ciężkość (Q)</div>
                `,
                legend2: `
                    <div class="flex items-center gap-2 text-cyan-400"><div class="w-3 h-3 bg-cyan-500 rounded-full"></div> Liniowe (θ)</div>
                    <div class="flex items-center gap-2 text-orange-400"><div class="w-3 h-3 bg-orange-500 rounded-full"></div> Dokładne (sin θ)</div>
                `,
                legend3: `
                    <div class="flex items-center gap-2 text-blue-400"><div class="w-3 h-3 bg-blue-500 rounded-full"></div> Wahadło A</div>
                    <div class="flex items-center gap-2 text-pink-400"><div class="w-3 h-3 bg-pink-500 rounded-full"></div> Wahadło B</div>
                `,
                period: 'Okres (T) ≈', freq: 'Częstotliwość (f) ≈',
                speedLabel: 'Szybkość symulacji'
            },
            en: {
                title: 'Pendulum Lab',
                tab1: 'Study (Single)', tab2: 'Linear vs Exact', tab3: 'Comparison (Dual)',
                start: 'Start', stop: 'Stop',
                legend1: `
                    <div class="flex items-center gap-2 text-green-400"><div class="w-3 h-3 bg-green-500 rounded-full"></div> Velocity (v)</div>
                    <div class="flex items-center gap-2 text-red-400"><div class="w-3 h-3 bg-red-500 rounded-full"></div> Tangential Force ($F_t$)</div>
                    <div class="flex items-center gap-2 text-yellow-400"><div class="w-3 h-3 bg-yellow-500 rounded-full"></div> Tension (T)</div>
                    <div class="flex items-center gap-2 text-gray-400"><div class="w-3 h-3 bg-gray-500 rounded-full"></div> Gravity (Fg)</div>
                `,
                legend2: `
                    <div class="flex items-center gap-2 text-cyan-400"><div class="w-3 h-3 bg-cyan-500 rounded-full"></div> Linear (θ)</div>
                    <div class="flex items-center gap-2 text-orange-400"><div class="w-3 h-3 bg-orange-500 rounded-full"></div> Exact (sin θ)</div>
                `,
                legend3: `
                    <div class="flex items-center gap-2 text-blue-400"><div class="w-3 h-3 bg-blue-500 rounded-full"></div> Pendulum A</div>
                    <div class="flex items-center gap-2 text-pink-400"><div class="w-3 h-3 bg-pink-500 rounded-full"></div> Pendulum B</div>
                `,
                period: 'Period (T) ≈', freq: 'Frequency (f) ≈',
                speedLabel: 'Simulation Speed'
            }
        };

        function init() {
            renderControls();
            resizeCanvas();
            updateChartScales();
            window.addEventListener('resize', resizeCanvas);
            drawFrame(); 
            updateStats();
            updateLangUI();
        }

        function updateSpeed(val) {
            timeSpeed = parseFloat(val);
            document.getElementById('val-speed').innerText = timeSpeed.toFixed(1) + 'x';
        }

        function updateChartScales() {
            const theta0 = sims[1].p1.initParams.theta;
            sims[1].chartAngle.setFixedScale(theta0);
            const estOmega = Math.abs(theta0) * Math.sqrt(sims[1].p1.g / sims[1].p1.L);
            sims[1].chartVel.setFixedScale(estOmega);
            
            const theta2 = sims[2].pExact.initParams.theta;
            sims[2].chartAngle.setFixedScale(theta2);
            sims[2].chartVel.setFixedScale(Math.abs(theta2) * Math.sqrt(9.81/1.5));

            const maxAngle = Math.max(sims[3].pA.initParams.theta, sims[3].pB.initParams.theta);
            sims[3].chartAngle.setFixedScale(maxAngle);
            sims[3].chartVel.setFixedScale(maxAngle * Math.sqrt(10/1.0));
        }

        function switchTab(id) {
            activeTab = id;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${id}-btn`).classList.add('active');
            
            [1,2,3].forEach(n => {
                const el = document.getElementById(`view-tab-${n}`);
                if(n === id) {
                    el.classList.remove('hidden');
                    el.classList.add('flex');
                } else {
                    el.classList.add('hidden');
                    el.classList.remove('flex');
                }
            });

            isPlaying = false;
            resetSim(); 
            renderControls();
            updateLangUI(); 
            resizeCanvas();
            updateChartScales(); 
        }

        function renderControls() {
            const container = document.getElementById('controls-container');
            container.innerHTML = '';
            const config = uiConfig[activeTab];
            
            config.forEach(item => {
                if (item.headerPL) {
                    const h = document.createElement('h3');
                    h.className = 'text-xs uppercase text-gray-500 font-bold border-b border-gray-700 pb-1 mt-4';
                    h.innerText = lang === 'pl' ? item.headerPL : item.headerEN;
                    container.appendChild(h);
                    return;
                }
                const div = document.createElement('div');
                div.innerHTML = `
                    <div class="flex justify-between mb-1">
                        <label class="text-sm text-cyan-400">${lang === 'pl' ? item.labelPL : item.labelEN}</label>
                        <span class="text-sm font-mono" id="val-${item.id}">${item.val} ${item.unit}</span>
                    </div>
                    <input type="range" min="${item.min}" max="${item.max}" step="${item.step}" value="${item.val}"
                        class="w-full accent-cyan-500" id="inp-${item.id}">
                `;
                container.appendChild(div);
                const inp = div.querySelector('input');
                inp.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    document.getElementById(`val-${item.id}`).innerText = `${val} ${item.unit}`;
                    const targets = Array.isArray(item.target) ? item.target : [item.target];
                    
                    if (item.prop === 'theta') {
                        if (isPlaying) togglePlay();
                        targets.forEach(tName => {
                            const obj = sims[activeTab][tName];
                            obj.theta = val * Math.PI / 180;
                            obj.initParams.theta = obj.theta; 
                            obj.omega = 0; 
                        });
                        const s = sims[activeTab];
                        if(s.chartAngle) s.chartAngle.clear();
                        if(s.chartVel) s.chartVel.clear();
                        updateChartScales(); 
                        drawFrame(); 
                    } else {
                        targets.forEach(tName => {
                            const obj = sims[activeTab][tName];
                            obj[item.prop] = val;
                            obj.initParams[item.prop] = val; 
                        });
                        if (!isPlaying) updateChartScales();
                        if (!isPlaying) drawFrame();
                    }
                    
                    if (activeTab === 1) updateStats(); 
                });
            });
        }

        function updateStats() {
            const out = document.getElementById('stats-output');
            const txt = translations[lang];
            if (activeTab === 1) {
                const p = sims[1].p1;
                const T = 2 * Math.PI * Math.sqrt(p.L / p.g);
                out.innerHTML = `
                    ${txt.period} <span class="text-white font-bold">${T.toFixed(2)} s</span><br>
                    ${txt.freq} <span class="text-white font-bold">${(1/T).toFixed(2)} Hz</span>
                `;
            } else { out.innerHTML = ''; }
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('btn-play');
            const txt = document.getElementById('txt-play');
            const t = translations[lang];
            if (isPlaying) {
                btn.classList.replace('bg-green-500', 'bg-red-500');
                btn.classList.replace('hover:bg-green-600', 'hover:bg-red-600');
                txt.innerText = t.stop;
                lastTime = performance.now();
                loop();
            } else {
                btn.classList.replace('bg-red-500', 'bg-green-500');
                btn.classList.replace('hover:bg-red-600', 'hover:bg-green-600');
                txt.innerText = t.start;
                cancelAnimationFrame(animationId);
            }
        }

        function resetSim() {
            isPlaying = false;
            const btn = document.getElementById('btn-play');
            const t = translations[lang];
            btn.classList.replace('bg-red-500', 'bg-green-500');
            btn.classList.replace('hover:bg-red-600', 'hover:bg-green-600');
            document.getElementById('txt-play').innerText = t.start;
            cancelAnimationFrame(animationId);
            Object.values(sims[activeTab]).forEach(obj => {
                if (obj.reset) obj.reset(); 
                if (obj.clear) obj.clear(); 
            });
            drawFrame();
            updateChartScales();
        }

        function toggleLang() {
            lang = lang === 'pl' ? 'en' : 'pl';
            updateLangUI();
            renderControls(); 
        }

        function updateLangUI() {
            const t = translations[lang];
            document.getElementById('app-title').innerText = t.title;
            document.getElementById('tab-1-btn').innerText = t.tab1;
            document.getElementById('tab-2-btn').innerText = t.tab2;
            document.getElementById('tab-3-btn').innerText = t.tab3;
            document.getElementById('txt-play').innerText = isPlaying ? t.stop : t.start;
            document.getElementById('lang-label').innerText = lang === 'pl' ? 'EN' : 'PL';
            document.getElementById('lbl-speed').innerText = t.speedLabel;
            
            const legDiv = document.getElementById('legend-content');
            if (activeTab === 1) legDiv.innerHTML = t.legend1;
            else if (activeTab === 2) legDiv.innerHTML = t.legend2;
            else if (activeTab === 3) legDiv.innerHTML = t.legend3;

            updateStats();
        }

        function loop(timestamp) {
            if (!isPlaying) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            let safeDt = Math.min(dt, 0.1); 
            safeDt *= timeSpeed;

            const steps = 20;
            const subDt = safeDt / steps;
            const s = sims[activeTab];

            for(let i=0; i<steps; i++) {
                if (activeTab === 1) {
                    s.p1.update(subDt);
                } else if (activeTab === 2) {
                    s.pLinear.update(subDt);
                    s.pExact.update(subDt);
                } else if (activeTab === 3) {
                    s.pA.update(subDt);
                    s.pB.update(subDt);
                }
            }
            
            if (activeTab === 1) {
                s.chartAngle.push(s.p1.theta, null);
                s.chartVel.push(s.p1.omega, null);
            } else if (activeTab === 2) {
                s.chartAngle.push(s.pLinear.theta, s.pExact.theta);
                s.chartVel.push(s.pLinear.omega, s.pExact.omega);
            } else if (activeTab === 3) {
                s.chartAngle.push(s.pA.theta, s.pB.theta);
                s.chartVel.push(s.pA.omega, s.pB.omega);
            }

            drawFrame();
            animationId = requestAnimationFrame(loop);
        }

        function drawFrame() {
            // Skala siłowa do rysowania
            const fScale = 3;
            
            // Funkcja pomocnicza do rysowania siatki
            const drawGrid = (ctx, scale, pivotY, maxL) => {
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)'; // Słaby szary
                ctx.lineWidth = 1;
                ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
                ctx.font = '10px monospace';
                
                // Rysujemy linie co 0.5m
                for (let d = 0.5; d <= maxL + 0.5; d += 0.5) {
                    const y = pivotY + d * scale;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(ctx.canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(d.toFixed(1) + 'm', 5, y - 2);
                }
            };

            // Funkcja do obliczenia skali i marginesu
            const calcScale = (cvs, pendulum) => {
                // Obliczamy ile pikseli zajmie wektor grawitacji (mg)
                const vecLen = pendulum.m * pendulum.g * fScale;
                // Margines to wektor + 10%
                const margin = vecLen * 1.1; 
                // Wysokość dostępna dla sznurka
                const availableH = cvs.height - 50 - margin; // 50 to pivotY
                // Skala (px/m)
                const scale = availableH / Math.max(pendulum.L, 0.1);
                return { scale, margin };
            };

            if (activeTab === 1) {
                const cvs = document.getElementById('canvas-1');
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                
                const p = sims[1].p1;
                const { scale } = calcScale(cvs, p);
                
                drawGrid(ctx, scale, 50, p.L);
                drawPendulum(ctx, p, cvs.width/2, 50, scale, true);
                
                sims[1].chartAngle.draw('#22d3ee', null, 'Wychylenie', null);
                sims[1].chartVel.draw('#4ade80', null, 'Prędkość', null);
            }
            else if (activeTab === 2) {
                const cvs = document.getElementById('canvas-2');
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                
                const p = sims[2].pExact;
                const { scale } = calcScale(cvs, p);
                
                drawGrid(ctx, scale, 50, p.L);
                drawPendulum(ctx, sims[2].pExact, cvs.width/2, 50, scale, false, '#f97316');
                drawPendulum(ctx, sims[2].pLinear, cvs.width/2, 50, scale, false, '#22d3ee');
                sims[2].chartAngle.draw('#22d3ee', '#f97316', 'Liniowe (θ)', 'Dokładne (sin θ)');
                sims[2].chartVel.draw('#22d3ee', '#f97316', 'Liniowe (ω)', 'Dokładne (ω)');
            }
            else if (activeTab === 3) {
                const cvs = document.getElementById('canvas-3');
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                
                // Używamy skali dopasowanej do dłuższego wahadła
                const pA = sims[3].pA;
                const pB = sims[3].pB;
                
                const resA = calcScale(cvs, pA);
                const resB = calcScale(cvs, pB);
                const scale = Math.min(resA.scale, resB.scale);
                const maxLenForGrid = Math.max(pA.L, pB.L);

                drawGrid(ctx, scale, 50, maxLenForGrid);
                
                drawPendulum(ctx, pA, cvs.width/2, 50, scale, false, '#60a5fa');
                drawPendulum(ctx, pB, cvs.width/2, 50, scale, false, '#f472b6');
                sims[3].chartAngle.draw('#60a5fa', '#f472b6', 'Wahadło A', 'Wahadło B');
                sims[3].chartVel.draw('#60a5fa', '#f472b6', 'Wahadło A', 'Wahadło B');
            }
        }

        function drawPendulum(ctx, p, pivotX, pivotY, scale, showVectors, colorOverride = null) {
            if (isNaN(p.theta)) return;
            const bobX = pivotX + Math.sin(p.theta) * (p.L * scale);
            const bobY = pivotY + Math.cos(p.theta) * (p.L * scale);

            // Sznurek
            ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(pivotX, pivotY); ctx.lineTo(bobX, bobY); ctx.stroke();
            
            // Pivot
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(pivotX - 3, pivotY - 3, 6, 6);

            // Bob
            ctx.fillStyle = colorOverride || '#22d3ee';
            ctx.beginPath(); ctx.arc(bobX, bobY, 14, 0, Math.PI * 2); ctx.fill();

            if (showVectors) {
                const fScale = 3; 
                
                // 1. Ciężkość (Q = mg)
                const Fg = p.m * p.g;
                drawArrow(ctx, bobX, bobY, bobX, bobY + Fg * fScale, '#9ca3af'); 
                
                // 2. Naciąg (N)
                const tensionMag = p.m * (p.g * Math.cos(p.theta) + p.L * p.omega * p.omega);
                const tX = -Math.sin(p.theta) * tensionMag * fScale;
                const tY = -Math.cos(p.theta) * tensionMag * fScale;
                drawArrow(ctx, bobX, bobY, bobX + tX, bobY + tY, '#eab308'); 
                
                // 3. Siła Styczna (Restoring Force, Ft)
                const tanX = - (p.m * p.g * Math.sin(p.theta)) * Math.cos(p.theta) * fScale;
                const tanY = - (p.m * p.g * Math.sin(p.theta)) * (-Math.sin(p.theta)) * fScale;
                drawArrow(ctx, bobX, bobY, bobX + tanX, bobY + tanY, '#f87171');

                // 4. Prędkość (v)
                const vMag = p.omega * p.L * 15;
                const vX = Math.cos(p.theta) * vMag;
                const vY = -Math.sin(p.theta) * vMag;
                drawArrow(ctx, bobX, bobY, bobX + vX, bobY + vY, '#4ade80');
            }
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            const headlen = 8;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 1) return;
            const angle = Math.atan2(dy, dx);
            ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toX - headlen * Math.cos(angle - Math.PI/6), toY - headlen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX, toY); ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI/6), toY - headlen * Math.sin(angle + Math.PI/6));
            ctx.fill();
        }

        function resizeCanvas() {
            document.querySelectorAll('canvas').forEach(cvs => {
                const parent = cvs.parentElement;
                if (parent) { cvs.width = parent.clientWidth; cvs.height = parent.clientHeight; }
            });
            drawFrame();
            if (sims[1].chartAngle) {
                sims[1].chartAngle.draw('#22d3ee', null, 'Wychylenie', null);
                sims[1].chartVel.draw('#4ade80', null, 'Prędkość', null);
            }
        }

        init();
    </script>
</body>
</html>