<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Rzutu Ukośnego</title>
    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Drobne poprawki dla suwaków w różnych przeglądarkach */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #22d3ee;
            margin-top: -6px; 
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
        /* Custom scrollbar dla panelu bocznego */
        aside::-webkit-scrollbar {
            width: 6px;
        }
        aside::-webkit-scrollbar-track {
            background: #1f2937; 
        }
        aside::-webkit-scrollbar-thumb {
            background: #4b5563; 
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans h-screen flex flex-col overflow-hidden">

    <!-- Nagłówek -->
    <header class="flex items-center justify-between px-6 py-4 bg-gray-800 border-b border-gray-700 shadow-md z-10 shrink-0">
        <div class="flex items-center space-x-2">
            <div class="bg-cyan-500 p-2 rounded-lg">
                <!-- Ikona ChevronRight -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="m9 18 6-6-6-6"/></svg>
            </div>
            <h1 id="app-title" class="text-xl font-bold tracking-wide">Symulator Rzutu Ukośnego</h1>
        </div>
        
        <button id="btn-lang" class="flex items-center px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm font-bold transition-colors border border-gray-600">
            <!-- Ikona Globe -->
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg>
            <span id="lang-label">EN</span>
        </button>
    </header>

    <!-- Główna zawartość -->
    <div class="flex flex-1 flex-col lg:flex-row overflow-hidden">
        
        <!-- Panel sterowania -->
        <aside class="w-full lg:w-80 bg-gray-800 p-6 flex flex-col gap-5 overflow-y-auto border-r border-gray-700 shadow-xl z-20 shrink-0">
            
            <!-- Sekcja: Parametry -->
            <div class="space-y-4">
                <h2 id="sect-settings" class="text-sm uppercase text-gray-400 font-semibold tracking-wider border-b border-gray-700 pb-2">
                    Parametry Początkowe
                </h2>
                
                <!-- v0 -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label id="lbl-v0" class="text-sm text-cyan-400">Prędkość początkowa (v₀)</label>
                        <span id="val-v0" class="text-sm font-mono">25 m/s</span>
                    </div>
                    <input type="range" id="inp-v0" min="1" max="200" step="1" value="100" class="w-full">
                </div>

                <!-- Angle -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label id="lbl-angle" class="text-sm text-cyan-400">Kąt wyrzutu (θ)</label>
                        <span id="val-angle" class="text-sm font-mono">37°</span>
                    </div>
                    <input type="range" id="inp-angle" min="0" max="90" step="1" value="37" class="w-full">
                </div>

                <!-- h0 -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label id="lbl-h0" class="text-sm text-cyan-400">Wysokość początkowa (h₀)</label>
                        <span id="val-h0" class="text-sm font-mono">0 m</span>
                    </div>
                    <input type="range" id="inp-h0" min="0" max="200" step="1" value="0" class="w-full">
                </div>
            </div>

            <!-- Sekcja: Akcje -->
            <div class="grid grid-cols-1 gap-2">
                <button id="btn-clear" class="flex items-center justify-center px-3 py-3 bg-gray-700 hover:bg-red-900/30 rounded text-sm transition-colors border border-gray-600 text-red-400 hover:text-red-300">
                    <!-- Ikona Trash2 -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    <span id="txt-clear">Wyczyść historię</span>
                </button>
            </div>

            <!-- Sekcja: Czas -->
            <div class="space-y-4">
                <h2 id="sect-time" class="text-sm uppercase text-gray-400 font-semibold tracking-wider border-b border-gray-700 pb-2">
                    Czas symulacji (t)
                </h2>
                
                <div class="flex items-center space-x-2 mb-2">
                    <button id="btn-play" class="flex-1 flex items-center justify-center py-2 rounded font-semibold transition-all shadow-lg bg-green-500 text-white hover:bg-green-600">
                        <!-- Ikona Play/Pause (zmieniana dynamicznie w JS) -->
                        <span id="icon-play-wrapper" class="mr-2">
                            <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                            <svg id="icon-pause" class="hidden" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                        </span>
                        <span id="txt-play">Odtwórz</span>
                    </button>
                    
                    <button id="btn-reset" class="p-2 bg-gray-700 hover:bg-gray-600 rounded text-gray-300 border border-gray-600" title="Reset">
                        <!-- Ikona RefreshCw -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                    </button>
                </div>

                <div>
                    <div class="flex justify-between mb-1">
                        <span class="text-xs text-gray-500">0.00s</span>
                        <span id="val-time" class="text-sm font-mono text-white">0.00 s</span>
                        <span id="val-totalTime" class="text-xs text-gray-500">0.00s</span>
                    </div>
                    <input type="range" id="inp-time" min="0" max="1" step="0.01" value="0" class="w-full accent-green-500">
                </div>
            </div>

            <!-- Sekcja: Wyniki -->
            <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3 mt-auto shadow-inner">
                <h2 id="sect-results" class="text-sm uppercase text-gray-400 font-semibold tracking-wider mb-2">
                    Wyniki Bieżące
                </h2>
                <div class="flex justify-between border-b border-gray-800 pb-1">
                    <span id="lbl-range" class="text-gray-400">Zasięg (R):</span>
                    <span id="res-range" class="font-mono font-bold text-cyan-300">0.00 m</span>
                </div>
                <div class="flex justify-between border-b border-gray-800 pb-1">
                    <span id="lbl-maxH" class="text-gray-400">Maks. wysokość (H):</span>
                    <span id="res-maxH" class="font-mono font-bold text-purple-300">0.00 m</span>
                </div>
                <div class="flex justify-between">
                    <span id="lbl-totalT" class="text-gray-400">Czas całkowity (T):</span>
                    <span id="res-totalT" class="font-mono font-bold text-yellow-300">0.00 s</span>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <main id="canvas-container" class="flex-1 relative bg-gray-900 overflow-hidden flex items-center justify-center">
            <canvas id="sim-canvas" class="block cursor-crosshair shadow-2xl"></canvas>
            
            <!-- Overlay z danymi -->
            <div class="absolute top-4 right-4 bg-gray-800/90 backdrop-blur-md p-4 rounded-lg border border-gray-600 text-xs font-mono pointer-events-none shadow-xl">
                <div id="ov-time" class="text-gray-400 mb-2 border-b border-gray-600 pb-1">t = 0.00 s</div>
                <div id="ov-x" class="text-cyan-400">x = 0.0 m</div>
                <div id="ov-y" class="text-purple-400">y = 0.0 m</div>
                <div class="mt-2 pt-2 border-t border-gray-600">
                   <div class="text-green-400 flex items-center gap-2">
                     <span class="w-2 h-2 rounded-full bg-green-400"></span>
                     <span id="ov-vx">vx = 0.0 m/s</span>
                   </div>
                   <div class="text-green-400 flex items-center gap-2">
                     <span class="w-2 h-2 rounded-full bg-green-400 opacity-50"></span>
                     <span id="ov-vy">vy = 0.0 m/s</span>
                   </div>
                   <div class="text-red-400 flex items-center gap-2 mt-1">
                     <span class="w-2 h-2 rounded-full bg-red-400"></span>
                     <span id="ov-ay">ay = -9.81 m/s²</span>
                   </div>
                </div>
            </div>
            
            <div id="ov-scale" class="absolute bottom-4 right-4 text-xs text-gray-600 font-mono">
                Max Scale: X=0m Y=0m
            </div>
        </main>
    </div>

    <script>
        // --- Konfiguracja i Stan ---
        const state = {
            v0: 100,
            angle: 37,
            h0: 0,
            g: 9.81,
            time: 0,
            isPlaying: false,
            lang: 'pl',
            history: [],
            hasLanded: false,
            // Obliczone wartości fizyczne
            phys: { vx0: 0, vy0: 0, totalTime: 0, range: 0, maxH: 0 }
        };

        // ZMIANA: Zmieniono nazwę zmiennej z 't' na 'translations', 
        // aby uniknąć kolizji z lokalnymi zmiennymi 't' (czas) w pętlach.
        const translations = {
            pl: {
                title: 'Symulator Rzutu Ukośnego',
                settings: 'Parametry Początkowe',
                results: 'Wyniki Bieżące',
                v0: 'Prędkość początkowa (v₀)',
                angle: 'Kąt wyrzutu (θ)',
                h0: 'Wysokość początkowa (h₀)',
                sectTime: 'Czas symulacji (t)',
                range: 'Zasięg (R)',
                maxH: 'Maks. wysokość (H)',
                totalT: 'Czas całkowity (T)',
                play: 'Odtwórz',
                pause: 'Pauza',
                clear: 'Wyczyść historię',
                switchTo: 'EN',
                ms: 'm/s',
                m: 'm',
                s: 's',
                deg: '°'
            },
            en: {
                title: 'Projectile Motion Simulator',
                settings: 'Initial Parameters',
                results: 'Current Results',
                v0: 'Initial Velocity (v₀)',
                angle: 'Launch Angle (θ)',
                h0: 'Initial Height (h₀)',
                sectTime: 'Simulation Time (t)',
                range: 'Range (R)',
                maxH: 'Max Height (H)',
                totalT: 'Total Time (T)',
                play: 'Play',
                pause: 'Pause',
                clear: 'Clear History',
                switchTo: 'PL',
                ms: 'm/s',
                m: 'm',
                s: 's',
                deg: '°'
            }
        };

        // Elementy DOM
        const els = {
            v0: document.getElementById('inp-v0'),
            angle: document.getElementById('inp-angle'),
            h0: document.getElementById('inp-h0'),
            time: document.getElementById('inp-time'),
            valV0: document.getElementById('val-v0'),
            valAngle: document.getElementById('val-angle'),
            valH0: document.getElementById('val-h0'),
            valTime: document.getElementById('val-time'),
            valTotalTime: document.getElementById('val-totalTime'),
            resRange: document.getElementById('res-range'),
            resMaxH: document.getElementById('res-maxH'),
            resTotalT: document.getElementById('res-totalT'),
            ovTime: document.getElementById('ov-time'),
            ovX: document.getElementById('ov-x'),
            ovY: document.getElementById('ov-y'),
            ovVx: document.getElementById('ov-vx'),
            ovVy: document.getElementById('ov-vy'),
            ovScale: document.getElementById('ov-scale'),
            btnPlay: document.getElementById('btn-play'),
            txtPlay: document.getElementById('txt-play'),
            iconPlay: document.getElementById('icon-play'),
            iconPause: document.getElementById('icon-pause'),
            btnReset: document.getElementById('btn-reset'),
            btnClear: document.getElementById('btn-clear'),
            btnLang: document.getElementById('btn-lang'),
            canvas: document.getElementById('sim-canvas'),
            container: document.getElementById('canvas-container'),
            // Labels for translation
            lblTitle: document.getElementById('app-title'),
            lblSettings: document.getElementById('sect-settings'),
            lblV0: document.getElementById('lbl-v0'),
            lblAngle: document.getElementById('lbl-angle'),
            lblH0: document.getElementById('lbl-h0'),
            lblSectTime: document.getElementById('sect-time'),
            lblResults: document.getElementById('sect-results'),
            lblRange: document.getElementById('lbl-range'),
            lblMaxH: document.getElementById('lbl-maxH'),
            lblTotalT: document.getElementById('lbl-totalT'),
            txtClear: document.getElementById('txt-clear'),
            langLabel: document.getElementById('lang-label')
        };

        // --- Fizyka ---
        function updatePhysics() {
            const rad = (state.angle * Math.PI) / 180;
            const vx = state.v0 * Math.cos(rad);
            const vy = state.v0 * Math.sin(rad);
            
            // Delta: vy^2 + 2*g*h0
            const delta = vy * vy + 2 * state.g * state.h0;
            const totalTime = (vy + Math.sqrt(delta)) / state.g;
            
            const range = vx * totalTime;
            
            let tH = vy / state.g;
            if (tH < 0) tH = 0;
            const maxH = state.h0 + vy * tH - 0.5 * state.g * tH * tH;

            state.phys = { vx0: vx, vy0: vy, totalTime, range, maxH };
            
            // Aktualizacja max suwaka czasu
            els.time.max = totalTime;
        }

        // --- Logika Aplikacji ---
        function handleParamChange(e, key) {
            state[key] = parseFloat(e.target.value);
            state.isPlaying = false;
            state.time = 0;
            state.hasLanded = false;
            updatePhysics();
            updateUI();
            draw();
        }

        function handleTimeChange(e) {
            state.time = parseFloat(e.target.value);
            state.isPlaying = false;
            updateUI(); // Żeby odświeżyć overlay
            draw();
        }

        function togglePlay() {
            if (state.time >= state.phys.totalTime) {
                // Restart jeśli koniec
                state.time = 0;
                state.hasLanded = false;
            }
            state.isPlaying = !state.isPlaying;
            updateUI();
            if (state.isPlaying) loop();
        }

        function resetSim() {
            state.isPlaying = false;
            state.time = 0;
            state.hasLanded = false;
            updateUI();
            draw();
        }

        function clearHistory() {
            state.history = [];
            resetSim();
        }

        function toggleLang() {
            state.lang = state.lang === 'pl' ? 'en' : 'pl';
            updateUI();
        }

        // --- Pętla Animacji ---
        let lastFrameTime = 0;
        function loop(timestamp) {
            if (!state.isPlaying) return;
            
            // Proste sterowanie czasem (zakładamy 60fps)
            // Lepsze byłoby użycie delta time, ale dla prostej symulacji fixed step jest ok
            // Żeby przyspieszyć długie loty:
            const dt = state.phys.totalTime > 10 ? 0.08 : 0.04;
            
            state.time += dt;
            
            // Sprawdzenie końca
            if (state.time >= state.phys.totalTime) {
                state.time = state.phys.totalTime;
                state.isPlaying = false;
                
                // Zapisz do historii
                if (!state.hasLanded && state.phys.totalTime > 0) {
                    state.hasLanded = true;
                    state.history.push({
                        v0: state.v0,
                        angle: state.angle,
                        h0: state.h0,
                        ...state.phys
                    });
                }
            }
            
            updateUI(); // Aktualizacja suwaka czasu i tekstów
            draw();
            
            if (state.isPlaying) {
                requestAnimationFrame(loop);
            }
        }

        // --- Rysowanie (Canvas) ---
        function getBounds() {
            let maxX = state.phys.range;
            let maxY = state.phys.maxH;

            state.history.forEach(item => {
                if (item.range > maxX) maxX = item.range;
                if (item.maxH > maxY) maxY = item.maxH;
            });

            return {
                maxX: Math.max(maxX * 1.2, 10),
                maxY: Math.max(maxY * 1.2, 10)
            };
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        function draw() {
            const ctx = els.canvas.getContext('2d');
            const W = els.canvas.width;
            const H = els.canvas.height;
            const bounds = getBounds();

            // Skalowanie
            const margin = 0.1;
            const scaleX = (W * (1 - 2 * margin)) / bounds.maxX;
            const scaleY = (H * (1 - 2 * margin)) / bounds.maxY;

            const toCanvasX = (x) => W * margin + x * scaleX;
            const toCanvasY = (y) => H * (1 - margin) - y * scaleY;

            // 1. Tło
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, W, H);

            // 2. Siatka
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#6B7280';
            ctx.font = '10px monospace';
            ctx.beginPath();
            
            // Poziome
            for(let i=0; i<=10; i++) {
                const yVal = (bounds.maxY / 10) * i;
                const y = toCanvasY(yVal);
                ctx.moveTo(W * margin, y);
                ctx.lineTo(W * (1-margin), y);
                ctx.fillText(Math.round(yVal), W*margin - 25, y + 3);
            }
            // Pionowe
            for(let i=0; i<=10; i++) {
                const xVal = (bounds.maxX / 10) * i;
                const x = toCanvasX(xVal);
                ctx.moveTo(x, H * (1-margin));
                ctx.lineTo(x, H * margin);
                ctx.fillText(Math.round(xVal), x - 5, H*(1-margin) + 15);
            }
            ctx.stroke();

            // Osie
            ctx.strokeStyle = '#9CA3AF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(W * margin, toCanvasY(0));
            ctx.lineTo(W * (1-margin), toCanvasY(0));
            ctx.moveTo(toCanvasX(0), H * (1-margin));
            ctx.lineTo(toCanvasX(0), H * margin);
            ctx.stroke();

            // 3. Historia
            state.history.forEach(item => {
                ctx.strokeStyle = '#4B5563';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const steps = 50;
                for (let i = 0; i <= steps; i++) {
                    const t = (item.totalTime / steps) * i;
                    const x = item.vx0 * t;
                    const y = item.h0 + item.vy0 * t - 0.5 * state.g * t * t;
                    const cx = toCanvasX(x);
                    const cy = toCanvasY(y);
                    if (i === 0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
                }
                ctx.stroke();
            });

            // 4. Aktualny tor
            ctx.strokeStyle = '#22D3EE';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const drawSteps = 100;
            const timeRatio = state.time / state.phys.totalTime;
            const currentSteps = Math.ceil(drawSteps * timeRatio);

            if (state.time > 0) {
                for (let i = 0; i <= currentSteps; i++) {
                    const t = (state.time / currentSteps) * i;
                    const x = state.phys.vx0 * t;
                    const y = state.h0 + state.phys.vy0 * t - 0.5 * state.g * t * t;
                    const cx = toCanvasX(x);
                    const cy = toCanvasY(y);
                    if (i === 0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
                }
                ctx.stroke();
            }

            // 5. Kulka
            const curX = state.phys.vx0 * state.time;
            const curY = state.h0 + state.phys.vy0 * state.time - 0.5 * state.g * state.time * state.time;
            const cx = toCanvasX(curX);
            const cy = toCanvasY(curY);

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fill();

            // 6. Wektory
            const vx = state.phys.vx0;
            const vy = state.phys.vy0 - state.g * state.time;
            
            // Wektory w skali ekranowej (stały mnożnik wizualny)
            drawArrow(ctx, cx, cy, cx + vx * scaleX * 0.2, cy - vy * scaleY * 0.2, '#4ADE80'); // V
            drawArrow(ctx, cx, cy, cx, cy + state.g * scaleY * 0.2, '#F87171'); // G

            // Update debug info scale
            els.ovScale.textContent = `Max Scale: X=${bounds.maxX.toFixed(0)}m Y=${bounds.maxY.toFixed(0)}m`;
        }

        // --- UI Update ---
        function updateUI() {
            // ZMIANA: Odwołujemy się do 'translations' zamiast 't'
            const txt = translations[state.lang];
            
            // Tłumaczenia
            els.lblTitle.textContent = txt.title;
            els.lblSettings.textContent = txt.settings;
            els.lblResults.textContent = txt.results;
            els.lblV0.textContent = txt.v0;
            els.lblAngle.textContent = txt.angle;
            els.lblH0.textContent = txt.h0;
            els.lblSectTime.textContent = txt.sectTime;
            els.lblRange.textContent = txt.range;
            els.lblMaxH.textContent = txt.maxH;
            els.lblTotalT.textContent = txt.totalT;
            els.txtPlay.textContent = state.isPlaying ? txt.pause : txt.play;
            els.txtClear.textContent = txt.clear;
            els.langLabel.textContent = txt.switchTo;

            // Wartości liczbowe
            els.valV0.textContent = `${state.v0} ${txt.ms}`;
            els.valAngle.textContent = `${state.angle}${txt.deg}`;
            els.valH0.textContent = `${state.h0} ${txt.m}`;
            els.valTime.textContent = `${state.time.toFixed(2)} ${txt.s}`;
            els.valTotalTime.textContent = `${state.phys.totalTime.toFixed(2)}${txt.s}`;
            
            els.resRange.textContent = `${state.phys.range.toFixed(2)} ${txt.m}`;
            els.resMaxH.textContent = `${state.phys.maxH.toFixed(2)} ${txt.m}`;
            els.resTotalT.textContent = `${state.phys.totalTime.toFixed(2)} ${txt.s}`;

            // Suwak czasu
            els.time.value = state.time;

            // Przyciski Play/Pause
            if (state.isPlaying) {
                els.btnPlay.classList.remove('bg-green-500', 'hover:bg-green-600');
                els.btnPlay.classList.add('bg-red-500', 'hover:bg-red-600');
                els.iconPlay.classList.add('hidden');
                els.iconPause.classList.remove('hidden');
            } else {
                els.btnPlay.classList.remove('bg-red-500', 'hover:bg-red-600');
                els.btnPlay.classList.add('bg-green-500', 'hover:bg-green-600');
                els.iconPlay.classList.remove('hidden');
                els.iconPause.classList.add('hidden');
            }

            // Overlay
            const curX = state.phys.vx0 * state.time;
            const curY = state.h0 + state.phys.vy0 * state.time - 0.5 * state.g * state.time * state.time;
            const curVy = state.phys.vy0 - state.g * state.time;

            els.ovTime.textContent = `t = ${state.time.toFixed(2)} s`;
            els.ovX.textContent = `x = ${curX.toFixed(1)} m`;
            els.ovY.textContent = `y = ${curY.toFixed(1)} m`;
            els.ovVx.textContent = `vx = ${state.phys.vx0.toFixed(1)} m/s`;
            els.ovVy.textContent = `vy = ${curVy.toFixed(1)} m/s`;
        }

        // --- Resize Canvas ---
        function resize() {
            els.canvas.width = els.container.clientWidth;
            els.canvas.height = els.container.clientHeight;
            draw();
        }

        // --- Event Listeners ---
        els.v0.addEventListener('input', (e) => handleParamChange(e, 'v0'));
        els.angle.addEventListener('input', (e) => handleParamChange(e, 'angle'));
        els.h0.addEventListener('input', (e) => handleParamChange(e, 'h0'));
        els.time.addEventListener('input', handleTimeChange);
        els.btnPlay.addEventListener('click', togglePlay);
        els.btnReset.addEventListener('click', resetSim);
        els.btnClear.addEventListener('click', clearHistory);
        els.btnLang.addEventListener('click', toggleLang);
        window.addEventListener('resize', resize);

        // --- Init ---
        updatePhysics();
        resize();
        updateUI();
        draw();

    </script>
</body>
</html>