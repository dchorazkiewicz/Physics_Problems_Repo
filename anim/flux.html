<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizualizacja Strumienia Pola Wektorowego</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJax for Formulas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    <!-- Three.js for 3D Rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #e2e8f0; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; outline: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }

        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #38bdf8; margin-top: -6px; cursor: pointer;
            box-shadow: 0 0 5px rgba(56, 189, 248, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }

        .panel-glass { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(10px); border-right: 1px solid #475569; }
        .info-card { background: rgba(15, 23, 42, 0.6); border: 1px solid #334155; border-radius: 0.5rem; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-slate-900 border-b border-slate-700 p-3 flex justify-between items-center z-20 shadow-lg shrink-0">
        <div class="flex items-center gap-3">
            <div class="bg-indigo-600/30 p-2 rounded text-indigo-400">
                <!-- Icon: Flux/Grid -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18"/><path d="M3 12h18"/><path d="m19 19-7-7 7-7"/><path d="m5 5 7 7-7 7"/></svg>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-wide text-indigo-100" id="app-title">Strumień Pola Wektorowego</h1>
                <div class="text-xs text-slate-400 font-mono">Flux Explorer</div>
            </div>
        </div>
        
        <div class="flex items-center gap-4">
            <div class="hidden md:block text-xs font-mono text-slate-500 bg-slate-800 px-2 py-1 rounded">
                $$ \Phi = \iint_S \vec{E} \cdot d\vec{S} $$
            </div>
            <button onclick="toggleLang()" class="px-3 py-1 bg-slate-800 hover:bg-slate-700 border border-slate-600 rounded text-xs font-bold transition-colors text-indigo-300">
                <span id="lang-btn">EN</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Sidebar Controls -->
        <aside class="w-80 panel-glass flex flex-col z-10 overflow-y-auto shrink-0 shadow-2xl p-5 space-y-6">
            
            <!-- Description -->
            <div class="info-card p-3 text-xs text-slate-300 leading-relaxed" id="desc-text">
                Wizualizacja definicji strumienia. Każdy mały kwadrat reprezentuje element powierzchni \( d\vec{S} \). Kolor oznacza wartość iloczynu skalarnego \( \vec{E} \cdot \vec{n} \).
            </div>

            <!-- Field Selection -->
            <div>
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block" id="lbl-field">Pole Wektorowe (E)</label>
                <div class="grid grid-cols-3 gap-1 bg-slate-800 p-1 rounded">
                    <button onclick="setField('uniform')" id="btn-f-uniform" class="px-2 py-1.5 text-xs font-bold rounded bg-indigo-600 text-white transition-colors">Jedn.</button>
                    <button onclick="setField('point')" id="btn-f-point" class="px-2 py-1.5 text-xs font-bold rounded hover:bg-slate-700 text-slate-400 transition-colors">Centr.</button>
                    <button onclick="setField('vortex')" id="btn-f-vortex" class="px-2 py-1.5 text-xs font-bold rounded hover:bg-slate-700 text-slate-400 transition-colors">Wir</button>
                </div>
            </div>

            <!-- Surface Selection -->
            <div>
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block" id="lbl-surface">Powierzchnia (S)</label>
                <div class="grid grid-cols-2 gap-1 bg-slate-800 p-1 rounded">
                    <button onclick="setSurface('plane')" id="btn-s-plane" class="px-2 py-1.5 text-xs font-bold rounded bg-indigo-600 text-white transition-colors">Płaszczyzna</button>
                    <button onclick="setSurface('cap')" id="btn-s-cap" class="px-2 py-1.5 text-xs font-bold rounded hover:bg-slate-700 text-slate-400 transition-colors">Czasza</button>
                </div>
            </div>

            <hr class="border-slate-700">

            <!-- Sliders -->
            <div class="space-y-4">
                <!-- Resolution -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-slate-400" id="lbl-res">Rozdzielczość (dS)</label>
                        <span id="val-res" class="text-xs font-mono text-indigo-400">8x8</span>
                    </div>
                    <input type="range" min="2" max="20" step="1" value="8" class="w-full" oninput="updateResolution(this.value)">
                </div>

                <!-- Rotation X -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-slate-400" id="lbl-rotX">Obrót X (Nachylenie)</label>
                        <span id="val-rotX" class="text-xs font-mono text-indigo-400">0°</span>
                    </div>
                    <input type="range" min="-90" max="90" step="1" value="0" class="w-full" oninput="updateRotationX(this.value)">
                </div>

                <!-- Rotation Y -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-slate-400" id="lbl-rotY">Obrót Y (Obieg)</label>
                        <span id="val-rotY" class="text-xs font-mono text-indigo-400">0°</span>
                    </div>
                    <input type="range" min="-180" max="180" step="1" value="0" class="w-full" oninput="updateRotationY(this.value)">
                </div>

                <!-- Rotation Z (New) -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-slate-400" id="lbl-rotZ">Obrót Z (Wokół osi)</label>
                        <span id="val-rotZ" class="text-xs font-mono text-indigo-400">0°</span>
                    </div>
                    <input type="range" min="-180" max="180" step="1" value="0" class="w-full" oninput="updateRotationZ(this.value)">
                </div>
            </div>

            <!-- Toggles -->
            <div class="space-y-2">
                <div class="flex items-center justify-between">
                    <label class="text-xs text-slate-400" id="lbl-vectors">Wektory Pola (E) na S</label>
                    <input type="checkbox" checked onchange="toggleVectors(this.checked)" class="accent-indigo-500">
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs text-slate-400" id="lbl-normals">Wektory Normalne (n)</label>
                    <input type="checkbox" checked onchange="toggleNormals(this.checked)" class="accent-emerald-500">
                </div>
                <div class="flex items-center justify-between">
                    <label class="text-xs text-slate-400" id="lbl-bgfield">Tło Pola (Siatka)</label>
                    <input type="checkbox" checked onchange="toggleBgField(this.checked)" class="accent-slate-500">
                </div>
            </div>

            <!-- Results -->
            <div class="mt-auto pt-4 border-t border-slate-700">
                <div class="info-card p-4">
                    <div class="text-[10px] uppercase text-slate-500 font-bold mb-1" id="lbl-total">Całkowity Strumień</div>
                    <div class="text-2xl font-mono font-bold text-indigo-100 flex items-center gap-2">
                        <span id="flux-value">0.00</span>
                        <span class="text-xs text-slate-600 font-normal">jednostek</span>
                    </div>
                </div>
                
                <!-- Legend -->
                <div class="flex gap-2 mt-2 text-[10px] justify-center">
                    <div class="flex items-center gap-1"><div class="w-3 h-3 bg-emerald-500 rounded-sm"></div> <span id="leg-out">Wypływ (+)</span></div>
                    <div class="flex items-center gap-1"><div class="w-3 h-3 bg-rose-500 rounded-sm"></div> <span id="leg-in">Wpływ (-)</span></div>
                    <div class="flex items-center gap-1"><div class="w-3 h-3 bg-slate-900 border border-slate-600 rounded-sm"></div> <span id="leg-zero">Zero</span></div>
                </div>
            </div>

        </aside>

        <!-- 3D Canvas -->
        <main class="flex-1 relative bg-black" id="canvas-container"></main>

        <!-- Overlay Guide -->
        <div class="absolute bottom-4 right-4 pointer-events-none select-none text-right">
            <div class="text-xs text-slate-500 bg-slate-900/50 backdrop-blur px-2 py-1 rounded" id="mouse-hint">
                LPM: Obrót • PPM: Przesuwanie • Rolka: Zoom
            </div>
        </div>

    </div>

    <script>
        // --- TRANSLATIONS ---
        const translations = {
            pl: {
                appTitle: "Strumień Pola",
                descText: "Wizualizacja całki powierzchniowej. Dzielimy powierzchnię na małe elementy dS. W każdym punkcie liczymy iloczyn skalarny wektora pola E (niebieski) i wektora normalnego n (zielony).",
                lblField: "Pole Wektorowe (E)",
                lblSurface: "Powierzchnia (S)",
                lblRes: "Rozdzielczość (dS)",
                lblRotX: "Obrót X (Nachylenie)",
                lblRotY: "Obrót Y (Obieg)",
                lblRotZ: "Obrót Z (Wokół osi)",
                lblVectors: "Wektory Pola (E) na S",
                lblNormals: "Wektory Normalne (n)",
                lblBgField: "Tło Pola (Siatka)",
                lblTotal: "Całkowity Strumień",
                legOut: "Wypływ (+)",
                legIn: "Wpływ (-)",
                legZero: "Zero (Ślizg)",
                mouseHint: "LPM: Obrót • PPM: Przesuwanie • Rolka: Zoom",
                fields: { uniform: "Jedn.", point: "Centr.", vortex: "Wir" },
                surfaces: { plane: "Płaszczyzna", cap: "Czasza" }
            },
            en: {
                appTitle: "Vector Flux",
                descText: "Visualization of the surface integral. We divide the surface into small dS elements. At each point, we calculate the dot product of the Field vector E (blue) and Normal vector n (green).",
                lblField: "Vector Field (E)",
                lblSurface: "Surface (S)",
                lblRes: "Resolution (dS)",
                lblRotX: "Rotation X (Tilt)",
                lblRotY: "Rotation Y (Spin)",
                lblRotZ: "Rotation Z (Roll)",
                lblVectors: "Field Vectors (E) on S",
                lblNormals: "Normal Vectors (n)",
                lblBgField: "Background Field (Grid)",
                lblTotal: "Total Flux",
                legOut: "Outflow (+)",
                legIn: "Inflow (-)",
                legZero: "Zero (Grazing)",
                mouseHint: "LMB: Rotate • RMB: Pan • Wheel: Zoom",
                fields: { uniform: "Unif.", point: "Centr.", vortex: "Vortex" },
                surfaces: { plane: "Plane", cap: "Cap" }
            }
        };

        // --- APP STATE ---
        const state = {
            lang: 'pl',
            field: 'uniform', // uniform, point, vortex
            surface: 'plane', // plane, cap
            resolution: 8,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            showField: true,
            showNormals: true,
            showBgField: true
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617); // Slate-950
        // Fog for depth
        scene.fog = new THREE.Fog(0x020617, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // Group to hold surface dynamic meshes
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Group to hold background field vectors
        const bgGroup = new THREE.Group();
        scene.add(bgGroup);

        // --- MATH & PHYSICS ---

        // Returns field vector E at position (x, y, z)
        function getFieldVector(pos) {
            const v = new THREE.Vector3();
            if (state.field === 'uniform') {
                v.set(1, 0, 0); // Along X axis
            } else if (state.field === 'point') {
                // Central field (1/r^2 magnitude visual approximation)
                v.copy(pos).normalize(); 
                // Scale visualization: stronger near center, but clamped
                const dist = pos.length();
                let mag = 2.0 / (dist * dist + 0.1); 
                mag = Math.min(mag, 1.5); // Clamp
                v.multiplyScalar(mag);
            } else if (state.field === 'vortex') {
                // Rotate around Y axis: (-z, 0, x)
                v.set(-pos.z, 0, pos.x).normalize();
            }
            return v;
        }

        function createArrow(dir, origin, length, color, headLength, headWidth) {
            // Hex color to int
            const col = new THREE.Color(color);
            const arrowHelper = new THREE.ArrowHelper(
                dir.clone().normalize(), 
                origin, 
                length, 
                col.getHex(), 
                headLength !== undefined ? headLength : 0.2 * length, 
                headWidth !== undefined ? headWidth : 0.1 * length
            );
            return arrowHelper;
        }

        // --- BACKGROUND FIELD LOGIC ---

        function rebuildBackground() {
            // Clear existing
            while(bgGroup.children.length > 0){ 
                const obj = bgGroup.children[0];
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
                bgGroup.remove(obj); 
            }

            if (!state.showBgField) return;

            // Grid settings
            const rangeX = 6, rangeY = 4, rangeZ = 6;
            const step = 2.5;

            for (let x = -rangeX; x <= rangeX; x += step) {
                for (let y = -rangeY; y <= rangeY; y += step) {
                    for (let z = -rangeZ; z <= rangeZ; z += step) {
                        // Skip vectors too close to center for point/vortex to avoid clutter/singularities
                        const pos = new THREE.Vector3(x, y, z);
                        if (state.field !== 'uniform' && pos.length() < 1.0) continue;

                        const field = getFieldVector(pos);
                        const len = Math.min(field.length(), 1.0) * 0.8; // Limit visual length
                        
                        // Create darker/transparent arrow
                        // ArrowHelper doesn't support transparency on line easily, using dark slate color
                        const arrow = createArrow(field, pos, len, 0x334155, len*0.3, len*0.15);
                        bgGroup.add(arrow);
                    }
                }
            }
        }

        // --- CORE REBUILD LOGIC ---

        function rebuildScene() {
            // 1. Clear Group
            while(mainGroup.children.length > 0){ 
                const obj = mainGroup.children[0];
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
                mainGroup.remove(obj); 
            }

            let totalFlux = 0;
            const res = state.resolution;
            
            // 2. Generate Surface Elements (Tiles)
            const geometry = state.surface === 'plane' 
                ? new THREE.PlaneGeometry(4, 4, res, res)
                : new THREE.SphereGeometry(2.5, res, res, 0, Math.PI * 2, 0, Math.PI * 0.4); // Cap

            // Apply User Rotation
            const rotX = THREE.Math.degToRad(state.rotX);
            const rotY = THREE.Math.degToRad(state.rotY);
            const rotZ = THREE.Math.degToRad(state.rotZ);
            
            const rotEuler = new THREE.Euler(rotX, rotY, rotZ);
            const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(rotEuler);
            geometry.applyMatrix4(rotMatrix);

            // Access attributes
            const posAttr = geometry.attributes.position;
            const normAttr = geometry.attributes.normal;
            const indexAttr = geometry.index;
            
            const colors = [];
            const count = indexAttr.count;

            for (let i = 0; i < count; i += 3) {
                const a = indexAttr.getX(i);
                const b = indexAttr.getX(i+1);
                const c = indexAttr.getX(i+2);

                const vA = new THREE.Vector3().fromBufferAttribute(posAttr, a);
                const vB = new THREE.Vector3().fromBufferAttribute(posAttr, b);
                const vC = new THREE.Vector3().fromBufferAttribute(posAttr, c);

                const center = new THREE.Vector3().addVectors(vA, vB).add(vC).divideScalar(3);

                const nA = new THREE.Vector3().fromBufferAttribute(normAttr, a);
                const nB = new THREE.Vector3().fromBufferAttribute(normAttr, b);
                const nC = new THREE.Vector3().fromBufferAttribute(normAttr, c);
                const normal = new THREE.Vector3().addVectors(nA, nB).add(nC).normalize();

                const field = getFieldVector(center);

                // Area & Flux
                const edge1 = new THREE.Vector3().subVectors(vB, vA);
                const edge2 = new THREE.Vector3().subVectors(vC, vA);
                const areaVector = new THREE.Vector3().crossVectors(edge1, edge2);
                const area = areaVector.length() * 0.5;

                const dot = field.dot(normal);
                const dFlux = dot * area;
                totalFlux += dFlux;

                // Color
                const intensity = Math.abs(dot); 
                let color = new THREE.Color();
                
                if (Math.abs(dot) < 0.05) {
                    color.setHex(0x1e293b); 
                } else if (dot > 0) {
                    color.setHSL(0.4, 1.0, 0.2 + 0.4 * Math.min(1, intensity)); 
                } else {
                    color.setHSL(0.95, 1.0, 0.3 + 0.4 * Math.min(1, intensity));
                }

                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);

                // Helpers
                if (state.showNormals) {
                    const arrowN = createArrow(normal, center, 0.6, 0x10b981); // Green Normal
                    mainGroup.add(arrowN);
                }
                
                if (state.showField) {
                    const arrowE = createArrow(field, center, 0.6, 0x6366f1); // Indigo Field
                    mainGroup.add(arrowE);
                }
            }

            const nonIndexedGeo = geometry.toNonIndexed();
            nonIndexedGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.MeshBasicMaterial({ 
                vertexColors: true, 
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            const mesh = new THREE.Mesh(nonIndexedGeo, material);
            mainGroup.add(mesh);

            const wireGeo = new THREE.WireframeGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x475569, opacity: 0.5, transparent: true });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            mainGroup.add(wireframe);

            document.getElementById('flux-value').innerText = totalFlux.toFixed(2);
        }

        // --- EVENTS & HANDLERS ---

        function updateResolution(val) {
            state.resolution = parseInt(val);
            document.getElementById('val-res').innerText = `${val}x${val}`;
            rebuildScene();
        }

        function updateRotationX(val) {
            state.rotX = parseInt(val);
            document.getElementById('val-rotX').innerText = `${val}°`;
            rebuildScene();
        }

        function updateRotationY(val) {
            state.rotY = parseInt(val);
            document.getElementById('val-rotY').innerText = `${val}°`;
            rebuildScene();
        }

        function updateRotationZ(val) {
            state.rotZ = parseInt(val);
            document.getElementById('val-rotZ').innerText = `${val}°`;
            rebuildScene();
        }

        function setField(type) {
            state.field = type;
            ['uniform', 'point', 'vortex'].forEach(id => {
                const btn = document.getElementById(`btn-f-${id}`);
                if (id === type) {
                    btn.classList.remove('text-slate-400', 'hover:bg-slate-700');
                    btn.classList.add('bg-indigo-600', 'text-white');
                } else {
                    btn.classList.add('text-slate-400', 'hover:bg-slate-700');
                    btn.classList.remove('bg-indigo-600', 'text-white');
                }
            });
            rebuildScene();
            rebuildBackground(); // Update BG field
        }

        function setSurface(type) {
            state.surface = type;
            ['plane', 'cap'].forEach(id => {
                const btn = document.getElementById(`btn-s-${id}`);
                if (id === type) {
                    btn.classList.remove('text-slate-400', 'hover:bg-slate-700');
                    btn.classList.add('bg-indigo-600', 'text-white');
                } else {
                    btn.classList.add('text-slate-400', 'hover:bg-slate-700');
                    btn.classList.remove('bg-indigo-600', 'text-white');
                }
            });
            rebuildScene();
        }

        function toggleVectors(checked) {
            state.showField = checked;
            rebuildScene();
        }

        function toggleNormals(checked) {
            state.showNormals = checked;
            rebuildScene();
        }

        function toggleBgField(checked) {
            state.showBgField = checked;
            rebuildBackground();
        }

        function toggleLang() {
            state.lang = state.lang === 'pl' ? 'en' : 'pl';
            document.getElementById('lang-btn').innerText = state.lang === 'pl' ? 'EN' : 'PL';
            
            const t = translations[state.lang];
            document.getElementById('app-title').innerText = t.appTitle;
            document.getElementById('desc-text').innerText = t.descText;
            document.getElementById('lbl-field').innerText = t.lblField;
            document.getElementById('lbl-surface').innerText = t.lblSurface;
            document.getElementById('lbl-res').innerText = t.lblRes;
            document.getElementById('lbl-rotX').innerText = t.lblRotX;
            document.getElementById('lbl-rotY').innerText = t.lblRotY;
            document.getElementById('lbl-rotZ').innerText = t.lblRotZ;
            document.getElementById('lbl-vectors').innerText = t.lblVectors;
            document.getElementById('lbl-normals').innerText = t.lblNormals;
            document.getElementById('lbl-bgfield').innerText = t.lblBgField;
            document.getElementById('lbl-total').innerText = t.lblTotal;
            document.getElementById('leg-out').innerText = t.legOut;
            document.getElementById('leg-in').innerText = t.legIn;
            document.getElementById('leg-zero').innerText = t.legZero;
            document.getElementById('mouse-hint').innerText = t.mouseHint;

            document.getElementById('btn-f-uniform').innerText = t.fields.uniform;
            document.getElementById('btn-f-point').innerText = t.fields.point;
            document.getElementById('btn-f-vortex').innerText = t.fields.vortex;
            document.getElementById('btn-s-plane').innerText = t.surfaces.plane;
            document.getElementById('btn-s-cap').innerText = t.surfaces.cap;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        // Init
        rebuildBackground();
        rebuildScene();
        animate();

    </script>
</body>
</html>